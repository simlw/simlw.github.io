<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="喜欢打羽毛球的程序员, 很高兴来到我的世界"><title>exports与module.exports的区别 | VTLDF</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">exports与module.exports的区别</h1><a id="logo" href="/.">VTLDF</a><p class="description">喜欢打羽毛球的程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">exports与module.exports的区别</h1><div class="post-meta">Nov 26, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>刚接触 node.js 模块的时候，exports 和 module.exports 经常感到困惑，两者都能用于模块导出，区别在哪？<br>弄明白下面三个问题以后，就可以很好的理解 exports 与 module.exports 的区别。</p>
<h2 id="1、exports-和-module-exports-是哪里来的"><a href="#1、exports-和-module-exports-是哪里来的" class="headerlink" title="1、exports 和 module.exports 是哪里来的"></a>1、exports 和 module.exports 是哪里来的</h2><p>Node.js 引用一个模块，在模块代码执行之前，实际会把模块代码包含在一个 wrapper 中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(exports, require, module, __filename, __dirname) &#123;</div><div class="line">    // 真正的模块代码在这里</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其中，上面匿名函数的参数中有 exports 和 module。参数中的 exports 就是这里的 exports 对象，moduel 就是 module.exports 中的 module。  所以，exports 与 module 其实是匿名函数的两个参数，是同一个层次的两个对象。   </p>
<p>通过 module wrapper，Node.js 实现了下面两点：   </p>
<ul>
<li>使得在 module 中定义的变量，作用域限制在了模块里面</li>
<li>可以使用 exports 和 module 导出模块中的值；并使用 <strong>filename 和 </strong>dirname 记录当前模块的文件名及文件的绝对路径  </li>
</ul>
<h2 id="2、exports-与-module-exports-是什么关系"><a href="#2、exports-与-module-exports-是什么关系" class="headerlink" title="2、exports 与 module.exports 是什么关系"></a>2、exports 与 module.exports 是什么关系</h2><p>exports 其实是 module.exports 的引用，为什么这么说？</p>
<p><strong>首先，看一下 module 是什么？</strong><br>module实际是一个 Module 类型的对象，表示的是当前模块（即当前文件）。我们可以在一个空文件中打印 module，看下 module 的具体内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// a.js</div><div class="line"></div><div class="line">console.log(module);</div><div class="line"></div><div class="line">// 下面是控制台输出结果</div><div class="line">// Module &#123;</div><div class="line">//   id: &apos;.&apos;,</div><div class="line">//   exports: &#123;&#125;,        // 即 module.exports</div><div class="line">//   parent: null,</div><div class="line">//   filename: &apos;/Users/xxx/dev/private/node/test.js&apos;,</div><div class="line">//   loaded: false,</div><div class="line">//   children: [],</div><div class="line">//   paths:</div><div class="line">//    [ &apos;/Users/xxx/dev/private/node/node_modules&apos;,</div><div class="line">//      &apos;/Users/xxx/dev/private/node_modules&apos;,</div><div class="line">//      &apos;/Users/xxx/dev/node_modules&apos;,</div><div class="line">//      &apos;/Users/xxx/node_modules&apos;,</div><div class="line">//      &apos;/Users/node_modules&apos;,</div><div class="line">//      &apos;/node_modules&apos; ] &#125;</div></pre></td></tr></table></figure></p>
<p>从上面的例子中可以看出，module 实际是一个表示当前模块（文件）的对象，包含了一些属性，其中就有 exports 属性，即 module.exports.</p>
<p><strong>然后，我们理解下 “exports 是 module.exports 的引用”</strong><br>exports 和 module.exports 都是对象，所谓引用实际指的是两者指向内存中的同一块地址。我们通过下面的简单代码来看下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// a.js </div><div class="line"></div><div class="line">console.log(module.exports === exports);</div><div class="line"></div><div class="line">// 输出结果是 true</div></pre></td></tr></table></figure></p>
<p>上面的代码结合前面的例子说明，module.exports 和 exports 都指向了内存中的一个 {} 对象，即 exports 是 module.exports 的引用。</p>
<h2 id="3、require-做了什么？"><a href="#3、require-做了什么？" class="headerlink" title="3、require 做了什么？"></a>3、require 做了什么？</h2><p>require 是每个模块都有的一个内部方法，require 方法到底干了什么？require 实际调用的是 Module._load() 方法，做的工作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Module._load = function(request, parent, isMain) &#123;</div><div class="line">  // 1. 检查当前模块是否已被缓存</div><div class="line">  // 2. 如果没被缓存，为当前模块创建一个 Module 实例，即 上面提到的 module </div><div class="line">  // 3. 将模块保存到缓存中</div><div class="line">  // 4. 根据文件地址，加载模块代码，并完成解析</div><div class="line">  // 5. 如果加载或者解析出错，从缓存中删除出错的模块</div><div class="line">  // 6. 返回 module.exports</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意最后，该方法返回的是 module.exports 对象。我们通过下面的几行代码说明这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// test.js</div><div class="line">let a = 1;</div><div class="line">exports.a = a;</div><div class="line">// &quot;下面这种写法等价于 exports.b = (x) =&gt; &#123;&#125;，都是为同一个 &#123;&#125; 对象添加属性</div><div class="line">// 这里也可以帮助理解 exports 是 module.exports 的引用</div><div class="line">module.exports.b = (x) =&gt; &#123; return x * x &#125;;</div><div class="line">console.log(&apos;inside module: &apos;, module.exports);</div><div class="line"></div><div class="line">// index.js</div><div class="line">console.log(&apos;outside module: &apos;, require(&apos;./test.js&apos;));</div><div class="line"></div><div class="line">// 执行 node index.js 输出结果</div><div class="line">// inside module: &#123; a: 1, b: [Function] &#125;</div><div class="line">// outside module: &#123; a: 1, b: [Function] &#125;</div></pre></td></tr></table></figure></p>
<h2 id="最后，通过下面两个问题来看下我们对-exports-和-module-exports-的理解"><a href="#最后，通过下面两个问题来看下我们对-exports-和-module-exports-的理解" class="headerlink" title="最后，通过下面两个问题来看下我们对 exports 和 module.exports 的理解"></a>最后，通过下面两个问题来看下我们对 exports 和 module.exports 的理解</h2><ul>
<li><p><strong>为什么可以使用 exports.foo() 导出一个模块的多个值、属性、函数</strong><br>这种方式实质是在为初始的 {} 对象添加属性，exports 和 module.exports 实质指向的还是原来的对象，即对象在内存中的地址并没有发生变化，只是对象的属性增加了。<br>（这里涉及到一些 JavaScript 中值的类型的知识，JavaScript 中的值的类型分为基本类型和引用类型，其在内存中的存储不太相同，不清楚的可以自己了解一下）</p>
</li>
<li><p><strong>当一个模块需要返回一个对象的时候，需要使用 module.exports</strong><br>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Student=function()&#123;</div><div class="line">    var name=&apos;&apos;;</div><div class="line">    this.setName=function(n)&#123;</div><div class="line">        name=n;</div><div class="line">    &#125;; </div><div class="line">    this.printName=function()&#123;</div><div class="line">        console.log(name)    ;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports=Student;       // 不能使用 exports = Student;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们想要模块返回 Student 对象，如果我们使用 exports = Student，即将 exports 指向了一个新的对象 Student（一块新的内存），而 module.exports 还是指向原来的对象，我们已经知道 require 最终返回的是 module.exports。<br>所以如果使用 exports = Student，在引用模块的文件中得不到 Studnet 对象。 </p>
<p>参考：<br><a href="https://nodejs.org/api/modules.html#modules_the_module_wrapper" target="_blank" rel="external">module wrapper</a><br><a href="http://fredkschott.com/post/2014/06/require-and-the-module-system/" target="_blank" rel="external">The Node.js Way - How <code>require()</code> Actually Works</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://vtldf.github.io/2016/11/26/exports与module-exports的区别/" data-id="cj4v7bzy90000c1xkyxg41fn9" class="article-share-link">分享</a><div class="tags"><a href="/tags/Node-js/">Node.js</a></div><div class="post-nav"><a href="/2017/01/07/从Execute Context Stack理解变量提升/" class="pre">从Execute Context Stack理解变量提升</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2138309"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://vtldf.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/08/从构造函数说原型链继承/">从构造函数说原型链继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/07/从Execute Context Stack理解变量提升/">从Execute Context Stack理解变量提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/26/exports与module-exports的区别/">exports与module.exports的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">VTLDF.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>